// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: caerus/user/v1/service.proto

package users

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/desmos-labs/caerus/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GetNonceRequest struct {
	// UserDesmosAddress represents the Desmos address of the user for which to get the nonce
	UserDesmosAddress string `protobuf:"bytes,1,opt,name=user_desmos_address,json=userDesmosAddress,proto3" json:"user_desmos_address,omitempty"`
}

func (m *GetNonceRequest) Reset()         { *m = GetNonceRequest{} }
func (m *GetNonceRequest) String() string { return proto.CompactTextString(m) }
func (*GetNonceRequest) ProtoMessage()    {}
func (*GetNonceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_136d38927a42eb1f, []int{0}
}
func (m *GetNonceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNonceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNonceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNonceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNonceRequest.Merge(m, src)
}
func (m *GetNonceRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetNonceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNonceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetNonceRequest proto.InternalMessageInfo

func (m *GetNonceRequest) GetUserDesmosAddress() string {
	if m != nil {
		return m.UserDesmosAddress
	}
	return ""
}

type GetNonceResponse struct {
	// Nonce represents the nonce value that should be signed in order to login the user
	Nonce string `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
}

func (m *GetNonceResponse) Reset()         { *m = GetNonceResponse{} }
func (m *GetNonceResponse) String() string { return proto.CompactTextString(m) }
func (*GetNonceResponse) ProtoMessage()    {}
func (*GetNonceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_136d38927a42eb1f, []int{1}
}
func (m *GetNonceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetNonceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetNonceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetNonceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetNonceResponse.Merge(m, src)
}
func (m *GetNonceResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetNonceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetNonceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetNonceResponse proto.InternalMessageInfo

func (m *GetNonceResponse) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

type LoginResponse struct {
	// Token represents the bearer token that can be used to authenticate requests from the user
	// without having to continuously perform the whole login procedure
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *LoginResponse) Reset()         { *m = LoginResponse{} }
func (m *LoginResponse) String() string { return proto.CompactTextString(m) }
func (*LoginResponse) ProtoMessage()    {}
func (*LoginResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_136d38927a42eb1f, []int{2}
}
func (m *LoginResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResponse.Merge(m, src)
}
func (m *LoginResponse) XXX_Size() int {
	return m.Size()
}
func (m *LoginResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResponse.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResponse proto.InternalMessageInfo

func (m *LoginResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type LogoutRequest struct {
	// LogoutFromAll tells whether the user should be logout from all sessions.
	// If false, the user will be logout only from the current session.
	LogoutFromAll bool `protobuf:"varint,1,opt,name=logout_from_all,json=logoutFromAll,proto3" json:"logout_from_all,omitempty"`
}

func (m *LogoutRequest) Reset()         { *m = LogoutRequest{} }
func (m *LogoutRequest) String() string { return proto.CompactTextString(m) }
func (*LogoutRequest) ProtoMessage()    {}
func (*LogoutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_136d38927a42eb1f, []int{3}
}
func (m *LogoutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogoutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogoutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogoutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogoutRequest.Merge(m, src)
}
func (m *LogoutRequest) XXX_Size() int {
	return m.Size()
}
func (m *LogoutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LogoutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LogoutRequest proto.InternalMessageInfo

func (m *LogoutRequest) GetLogoutFromAll() bool {
	if m != nil {
		return m.LogoutFromAll
	}
	return false
}

type RefreshSessionResponse struct {
	// Token represents the new token that should be used to authenticate future requests
	// after the refresh of the session.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *RefreshSessionResponse) Reset()         { *m = RefreshSessionResponse{} }
func (m *RefreshSessionResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshSessionResponse) ProtoMessage()    {}
func (*RefreshSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_136d38927a42eb1f, []int{4}
}
func (m *RefreshSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RefreshSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshSessionResponse.Merge(m, src)
}
func (m *RefreshSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *RefreshSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshSessionResponse proto.InternalMessageInfo

func (m *RefreshSessionResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type RegisterNotificationDeviceTokenRequest struct {
	// DeviceToken represents the device token that should be registered as a notification device token for the user
	DeviceToken string `protobuf:"bytes,1,opt,name=device_token,json=deviceToken,proto3" json:"device_token,omitempty"`
}

func (m *RegisterNotificationDeviceTokenRequest) Reset() {
	*m = RegisterNotificationDeviceTokenRequest{}
}
func (m *RegisterNotificationDeviceTokenRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterNotificationDeviceTokenRequest) ProtoMessage()    {}
func (*RegisterNotificationDeviceTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_136d38927a42eb1f, []int{5}
}
func (m *RegisterNotificationDeviceTokenRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterNotificationDeviceTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterNotificationDeviceTokenRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterNotificationDeviceTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterNotificationDeviceTokenRequest.Merge(m, src)
}
func (m *RegisterNotificationDeviceTokenRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterNotificationDeviceTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterNotificationDeviceTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterNotificationDeviceTokenRequest proto.InternalMessageInfo

func (m *RegisterNotificationDeviceTokenRequest) GetDeviceToken() string {
	if m != nil {
		return m.DeviceToken
	}
	return ""
}

func init() {
	proto.RegisterType((*GetNonceRequest)(nil), "caerus.users.v1.GetNonceRequest")
	proto.RegisterType((*GetNonceResponse)(nil), "caerus.users.v1.GetNonceResponse")
	proto.RegisterType((*LoginResponse)(nil), "caerus.users.v1.LoginResponse")
	proto.RegisterType((*LogoutRequest)(nil), "caerus.users.v1.LogoutRequest")
	proto.RegisterType((*RefreshSessionResponse)(nil), "caerus.users.v1.RefreshSessionResponse")
	proto.RegisterType((*RegisterNotificationDeviceTokenRequest)(nil), "caerus.users.v1.RegisterNotificationDeviceTokenRequest")
}

func init() { proto.RegisterFile("caerus/user/v1/service.proto", fileDescriptor_136d38927a42eb1f) }

var fileDescriptor_136d38927a42eb1f = []byte{
	// 485 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x86, 0x63, 0xa1, 0x56, 0x65, 0x69, 0x08, 0x2c, 0xa8, 0x42, 0x06, 0x99, 0xd6, 0x12, 0xa5,
	0x42, 0x62, 0xad, 0xc2, 0xa1, 0x47, 0x08, 0x0a, 0xf4, 0x00, 0x2a, 0xc2, 0x81, 0x0b, 0x17, 0xcb,
	0xb1, 0x27, 0xae, 0x85, 0xed, 0x09, 0x3b, 0xeb, 0x48, 0x7d, 0x0b, 0x1e, 0x8b, 0x63, 0x8f, 0x1c,
	0x51, 0xf2, 0x06, 0x3c, 0x01, 0xda, 0xdd, 0x58, 0x49, 0xdb, 0x18, 0x7a, 0xdc, 0xf9, 0xff, 0xf9,
	0xbd, 0xfe, 0x66, 0x96, 0x3d, 0x4a, 0x62, 0x90, 0x35, 0x05, 0x35, 0x81, 0x0c, 0xa6, 0x87, 0x01,
	0x81, 0x9c, 0xe6, 0x09, 0x88, 0x89, 0x44, 0x85, 0xbc, 0x67, 0x55, 0xa1, 0x55, 0x12, 0xd3, 0x43,
	0xd7, 0x5b, 0xd8, 0xd5, 0xd9, 0x04, 0x48, 0xfb, 0x25, 0x7c, 0xaf, 0x81, 0x14, 0xd9, 0x06, 0xf7,
	0x61, 0x86, 0x98, 0x15, 0x10, 0x98, 0xd3, 0xa8, 0x1e, 0x07, 0x50, 0x4e, 0xd4, 0x99, 0x15, 0xfd,
	0x3e, 0xeb, 0x1d, 0x83, 0x3a, 0xc1, 0x2a, 0x81, 0xd0, 0xb6, 0x71, 0xc1, 0xee, 0xe9, 0xec, 0x28,
	0x05, 0x2a, 0x91, 0xa2, 0x38, 0x4d, 0x25, 0x10, 0x3d, 0x70, 0x76, 0x9d, 0x83, 0x9b, 0xe1, 0x5d,
	0x2d, 0x0d, 0x8c, 0xd2, 0xb7, 0x82, 0x7f, 0xc0, 0xee, 0x2c, 0x23, 0x68, 0x82, 0x15, 0x01, 0xbf,
	0xcf, 0x36, 0x2a, 0x5d, 0x58, 0x74, 0xd9, 0x83, 0xff, 0x84, 0x75, 0x3f, 0x60, 0x96, 0x57, 0xab,
	0x36, 0x85, 0xdf, 0xa0, 0x6a, 0x6c, 0xe6, 0xe0, 0x1f, 0x19, 0x1b, 0xd6, 0xaa, 0xb9, 0xd1, 0x3e,
	0xeb, 0x15, 0xa6, 0x10, 0x8d, 0x25, 0x96, 0x51, 0x5c, 0x14, 0xa6, 0x61, 0x2b, 0xec, 0xda, 0xf2,
	0x3b, 0x89, 0x65, 0xbf, 0x28, 0x7c, 0xc1, 0x76, 0x42, 0x18, 0x4b, 0xa0, 0xd3, 0x21, 0x10, 0xe5,
	0xf8, 0xbf, 0x0f, 0xbd, 0x67, 0xfb, 0x21, 0x64, 0x39, 0x29, 0x90, 0x27, 0xa8, 0xf2, 0x71, 0x9e,
	0xc4, 0x2a, 0xc7, 0x6a, 0x00, 0x1a, 0xf7, 0x67, 0x6d, 0x69, 0x6e, 0xb0, 0xc7, 0xb6, 0x53, 0x53,
	0x8d, 0x56, 0x63, 0x6e, 0xa5, 0x4b, 0xe7, 0x8b, 0x3f, 0x37, 0xd8, 0xf6, 0x17, 0x3d, 0x93, 0xa1,
	0x1d, 0x17, 0xff, 0xc8, 0xb6, 0x1a, 0x2e, 0x7c, 0x57, 0x5c, 0x9a, 0x9a, 0xb8, 0x44, 0xdd, 0xdd,
	0xfb, 0x87, 0x63, 0xf1, 0x13, 0xc7, 0x6c, 0xc3, 0xe0, 0xe3, 0x5e, 0xe3, 0x35, 0x23, 0xd7, 0xde,
	0x61, 0x9e, 0x55, 0x90, 0x36, 0x59, 0xde, 0x95, 0xac, 0x8b, 0xd8, 0x3f, 0xb1, 0xdb, 0x17, 0x39,
	0xf1, 0x1d, 0x61, 0x97, 0x44, 0x34, 0x4b, 0x22, 0xde, 0xea, 0x25, 0x71, 0x9f, 0x5e, 0x49, 0x6a,
	0x01, 0x2c, 0xd9, 0xe3, 0x06, 0xa5, 0xc5, 0xb7, 0x0a, 0xd4, 0x00, 0xe2, 0x47, 0x6b, 0xb2, 0xae,
	0x03, 0xdf, 0x6d, 0xb9, 0x1c, 0x7f, 0xcd, 0x36, 0xed, 0x9e, 0xf0, 0xb5, 0x3f, 0xbc, 0x5c, 0xa0,
	0xd6, 0x84, 0x57, 0xac, 0x3b, 0x80, 0x02, 0x14, 0xf4, 0x93, 0x04, 0xeb, 0x4a, 0xb5, 0x72, 0x68,
	0xa9, 0xbf, 0x19, 0xfc, 0x9c, 0x79, 0xce, 0xf9, 0xcc, 0x73, 0x7e, 0xcf, 0x3c, 0xe7, 0xc7, 0xdc,
	0xeb, 0x9c, 0xcf, 0xbd, 0xce, 0xaf, 0xb9, 0xd7, 0xf9, 0xfa, 0x2c, 0xcb, 0xd5, 0x69, 0x3d, 0x12,
	0x09, 0x96, 0x81, 0x7d, 0x49, 0xcf, 0x8b, 0x78, 0x44, 0xc1, 0xe2, 0xb1, 0x4a, 0xac, 0x15, 0xd8,
	0x27, 0x4e, 0xa3, 0x4d, 0x93, 0xfa, 0xf2, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x16, 0xe4, 0x43,
	0xca, 0xf9, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UsersServiceClient is the client API for UsersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UsersServiceClient interface {
	// GetNonce allows to get a nonce that can later be signed to login the user inside the APIs
	GetNonce(ctx context.Context, in *GetNonceRequest, opts ...grpc.CallOption) (*GetNonceResponse, error)
	// Login allows to finish the login procedure and get a bearer token to authenticate future requests
	Login(ctx context.Context, in *types.SignedRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	// RefreshSession allows the user to refresh their current session
	RefreshSession(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RefreshSessionResponse, error)
	// RegisterDeviceNotificationToken allows to register a notification device tokens for future notifications
	RegisterDeviceNotificationToken(ctx context.Context, in *RegisterNotificationDeviceTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Logout allows the user to logout from either the current or all sessions
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteAccount allows the user to delete their account
	// Note: Data will be deleted after 14 days of inactivity. During this time,
	// the user can login again in order to stop the deletion procedure.
	DeleteAccount(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type usersServiceClient struct {
	cc grpc1.ClientConn
}

func NewUsersServiceClient(cc grpc1.ClientConn) UsersServiceClient {
	return &usersServiceClient{cc}
}

func (c *usersServiceClient) GetNonce(ctx context.Context, in *GetNonceRequest, opts ...grpc.CallOption) (*GetNonceResponse, error) {
	out := new(GetNonceResponse)
	err := c.cc.Invoke(ctx, "/caerus.users.v1.UsersService/GetNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersServiceClient) Login(ctx context.Context, in *types.SignedRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/caerus.users.v1.UsersService/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersServiceClient) RefreshSession(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RefreshSessionResponse, error) {
	out := new(RefreshSessionResponse)
	err := c.cc.Invoke(ctx, "/caerus.users.v1.UsersService/RefreshSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersServiceClient) RegisterDeviceNotificationToken(ctx context.Context, in *RegisterNotificationDeviceTokenRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/caerus.users.v1.UsersService/RegisterDeviceNotificationToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/caerus.users.v1.UsersService/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersServiceClient) DeleteAccount(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/caerus.users.v1.UsersService/DeleteAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsersServiceServer is the server API for UsersService service.
type UsersServiceServer interface {
	// GetNonce allows to get a nonce that can later be signed to login the user inside the APIs
	GetNonce(context.Context, *GetNonceRequest) (*GetNonceResponse, error)
	// Login allows to finish the login procedure and get a bearer token to authenticate future requests
	Login(context.Context, *types.SignedRequest) (*LoginResponse, error)
	// RefreshSession allows the user to refresh their current session
	RefreshSession(context.Context, *emptypb.Empty) (*RefreshSessionResponse, error)
	// RegisterDeviceNotificationToken allows to register a notification device tokens for future notifications
	RegisterDeviceNotificationToken(context.Context, *RegisterNotificationDeviceTokenRequest) (*emptypb.Empty, error)
	// Logout allows the user to logout from either the current or all sessions
	Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error)
	// DeleteAccount allows the user to delete their account
	// Note: Data will be deleted after 14 days of inactivity. During this time,
	// the user can login again in order to stop the deletion procedure.
	DeleteAccount(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
}

// UnimplementedUsersServiceServer can be embedded to have forward compatible implementations.
type UnimplementedUsersServiceServer struct {
}

func (*UnimplementedUsersServiceServer) GetNonce(ctx context.Context, req *GetNonceRequest) (*GetNonceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNonce not implemented")
}
func (*UnimplementedUsersServiceServer) Login(ctx context.Context, req *types.SignedRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (*UnimplementedUsersServiceServer) RefreshSession(ctx context.Context, req *emptypb.Empty) (*RefreshSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshSession not implemented")
}
func (*UnimplementedUsersServiceServer) RegisterDeviceNotificationToken(ctx context.Context, req *RegisterNotificationDeviceTokenRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDeviceNotificationToken not implemented")
}
func (*UnimplementedUsersServiceServer) Logout(ctx context.Context, req *LogoutRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (*UnimplementedUsersServiceServer) DeleteAccount(ctx context.Context, req *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}

func RegisterUsersServiceServer(s grpc1.Server, srv UsersServiceServer) {
	s.RegisterService(&_UsersService_serviceDesc, srv)
}

func _UsersService_GetNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNonceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServiceServer).GetNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/caerus.users.v1.UsersService/GetNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServiceServer).GetNonce(ctx, req.(*GetNonceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsersService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.SignedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/caerus.users.v1.UsersService/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServiceServer).Login(ctx, req.(*types.SignedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsersService_RefreshSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServiceServer).RefreshSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/caerus.users.v1.UsersService/RefreshSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServiceServer).RefreshSession(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsersService_RegisterDeviceNotificationToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterNotificationDeviceTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServiceServer).RegisterDeviceNotificationToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/caerus.users.v1.UsersService/RegisterDeviceNotificationToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServiceServer).RegisterDeviceNotificationToken(ctx, req.(*RegisterNotificationDeviceTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsersService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/caerus.users.v1.UsersService/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsersService_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServiceServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/caerus.users.v1.UsersService/DeleteAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServiceServer).DeleteAccount(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _UsersService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "caerus.users.v1.UsersService",
	HandlerType: (*UsersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNonce",
			Handler:    _UsersService_GetNonce_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _UsersService_Login_Handler,
		},
		{
			MethodName: "RefreshSession",
			Handler:    _UsersService_RefreshSession_Handler,
		},
		{
			MethodName: "RegisterDeviceNotificationToken",
			Handler:    _UsersService_RegisterDeviceNotificationToken_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _UsersService_Logout_Handler,
		},
		{
			MethodName: "DeleteAccount",
			Handler:    _UsersService_DeleteAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "caerus/user/v1/service.proto",
}

func (m *GetNonceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNonceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetNonceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserDesmosAddress) > 0 {
		i -= len(m.UserDesmosAddress)
		copy(dAtA[i:], m.UserDesmosAddress)
		i = encodeVarintService(dAtA, i, uint64(len(m.UserDesmosAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetNonceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNonceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetNonceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintService(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LoginResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintService(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogoutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogoutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogoutFromAll {
		i--
		if m.LogoutFromAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RefreshSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintService(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterNotificationDeviceTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterNotificationDeviceTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterNotificationDeviceTokenRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceToken) > 0 {
		i -= len(m.DeviceToken)
		copy(dAtA[i:], m.DeviceToken)
		i = encodeVarintService(dAtA, i, uint64(len(m.DeviceToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	offset -= sovService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *GetNonceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserDesmosAddress)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *GetNonceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *LoginResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *LogoutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogoutFromAll {
		n += 2
	}
	return n
}

func (m *RefreshSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *RegisterNotificationDeviceTokenRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceToken)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func sovService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetNonceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNonceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNonceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserDesmosAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserDesmosAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNonceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNonceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNonceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogoutFromAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogoutFromAll = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterNotificationDeviceTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterNotificationDeviceTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterNotificationDeviceTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupService = fmt.Errorf("proto: unexpected end of group")
)
