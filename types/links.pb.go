// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: caerus/types/v1/links.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LinkConfig struct {
	// OpenGraph allows to handle Facebook properties
	OpenGraph *OpenGraphConfig `protobuf:"bytes,1,opt,name=open_graph,json=openGraph,proto3" json:"open_graph"`
	// Twitter contains custom Twitter properties
	Twitter *TwitterConfig `protobuf:"bytes,2,opt,name=twitter,proto3" json:"twitter"`
	// CustomData should contain the custom data that will be added to the
	// generated link. This should be a JSON-encoded map of key-pair values.
	CustomData []byte `protobuf:"bytes,3,opt,name=custom_data,json=customData,proto3" json:"custom_data"`
	// Redirections allows to navigate to different locations based on device
	// information. Note: Navigation URLs must be websites, not deep links
	Redirections *RedirectionsConfig `protobuf:"bytes,4,opt,name=redirections,proto3" json:"redirections"`
	// DeepLinking allows to navigate to different locations based on device
	// information
	DeepLinking *DeepLinkConfig `protobuf:"bytes,5,opt,name=deep_linking,json=deepLinking,proto3" json:"deep_linking"`
}

func (m *LinkConfig) Reset()         { *m = LinkConfig{} }
func (m *LinkConfig) String() string { return proto.CompactTextString(m) }
func (*LinkConfig) ProtoMessage()    {}
func (*LinkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_10e7b6bdafd859e9, []int{0}
}
func (m *LinkConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkConfig.Merge(m, src)
}
func (m *LinkConfig) XXX_Size() int {
	return m.Size()
}
func (m *LinkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_LinkConfig proto.InternalMessageInfo

func (m *LinkConfig) GetOpenGraph() *OpenGraphConfig {
	if m != nil {
		return m.OpenGraph
	}
	return nil
}

func (m *LinkConfig) GetTwitter() *TwitterConfig {
	if m != nil {
		return m.Twitter
	}
	return nil
}

func (m *LinkConfig) GetCustomData() []byte {
	if m != nil {
		return m.CustomData
	}
	return nil
}

func (m *LinkConfig) GetRedirections() *RedirectionsConfig {
	if m != nil {
		return m.Redirections
	}
	return nil
}

func (m *LinkConfig) GetDeepLinking() *DeepLinkConfig {
	if m != nil {
		return m.DeepLinking
	}
	return nil
}

// OpenGraphConfig contains the Open Graph properties that will be added to the
// generated link
type OpenGraphConfig struct {
	Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"$og_title,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"$og_description,omitempty"`
	ImageUrl    string `protobuf:"bytes,3,opt,name=image_url,json=imageUrl,proto3" json:"$og_image_url,omitempty"`
}

func (m *OpenGraphConfig) Reset()         { *m = OpenGraphConfig{} }
func (m *OpenGraphConfig) String() string { return proto.CompactTextString(m) }
func (*OpenGraphConfig) ProtoMessage()    {}
func (*OpenGraphConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_10e7b6bdafd859e9, []int{1}
}
func (m *OpenGraphConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpenGraphConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpenGraphConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpenGraphConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpenGraphConfig.Merge(m, src)
}
func (m *OpenGraphConfig) XXX_Size() int {
	return m.Size()
}
func (m *OpenGraphConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_OpenGraphConfig.DiscardUnknown(m)
}

var xxx_messageInfo_OpenGraphConfig proto.InternalMessageInfo

func (m *OpenGraphConfig) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *OpenGraphConfig) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *OpenGraphConfig) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

// TwitterConfig contains the Twitter properties that will be added to the
// generated link
type TwitterConfig struct {
	CardType    string `protobuf:"bytes,1,opt,name=card_type,json=cardType,proto3" json:"$twitter_card,omitempty"`
	Title       string `protobuf:"bytes,2,opt,name=title,proto3" json:"$twitter_title,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"$twitter_description,omitempty"`
	ImageUrl    string `protobuf:"bytes,4,opt,name=image_url,json=imageUrl,proto3" json:"$twitter_image_url,omitempty"`
}

func (m *TwitterConfig) Reset()         { *m = TwitterConfig{} }
func (m *TwitterConfig) String() string { return proto.CompactTextString(m) }
func (*TwitterConfig) ProtoMessage()    {}
func (*TwitterConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_10e7b6bdafd859e9, []int{2}
}
func (m *TwitterConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TwitterConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TwitterConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TwitterConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TwitterConfig.Merge(m, src)
}
func (m *TwitterConfig) XXX_Size() int {
	return m.Size()
}
func (m *TwitterConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TwitterConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TwitterConfig proto.InternalMessageInfo

func (m *TwitterConfig) GetCardType() string {
	if m != nil {
		return m.CardType
	}
	return ""
}

func (m *TwitterConfig) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *TwitterConfig) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TwitterConfig) GetImageUrl() string {
	if m != nil {
		return m.ImageUrl
	}
	return ""
}

// RedirectionsConfig contains the redirections that will be added to the
// generated link
type RedirectionsConfig struct {
	// Change the redirect endpoint for all platforms - so you don't have to
	// enable it by platform. Note that Branch will forward all robots to this
	// URL, which overrides any OG tags entered in the link. System-wide Default
	// URL (set in Link Settings)
	FallbackUrl string `protobuf:"bytes,1,opt,name=fallback_url,json=fallbackUrl,proto3" json:"$fallback_url,omitempty"`
	// Redirect URL for desktop devices - mobile users will default to the app
	// store.
	DesktopUrl string `protobuf:"bytes,2,opt,name=desktop_url,json=desktopUrl,proto3" json:"$desktop_url,omitempty"`
	// Change the redirect endpoint for iOS App Store page for your app (set in
	// Link Settings)
	IosUrl string `protobuf:"bytes,3,opt,name=ios_url,json=iosUrl,proto3" json:"$ios_url,omitempty"`
	// Change the redirect endpoint for Android Play Store page for your app (set
	// in Link Settings)
	AndroidUrl string `protobuf:"bytes,4,opt,name=android_url,json=androidUrl,proto3" json:"$android_url,omitempty"`
	// Force to open the $fallback_url instead of the app
	WebOnly bool `protobuf:"varint,5,opt,name=web_only,json=webOnly,proto3" json:"$web_only,omitempty"`
	// Force to open the $windows_desktop_url, $mac_desktop_url, $desktop_url, or
	// $fallback_url in this order of precedence instead of the app
	DesktopWebOnly bool `protobuf:"varint,6,opt,name=desktop_web_only,json=desktopWebOnly,proto3" json:"$desktop_web_only,omitempty"`
	// Force to open the $ios_url, $android_url, or $fallback_url in this order of
	// precedence instead of the app
	MobileWebOnly bool `protobuf:"varint,7,opt,name=mobile_web_only,json=mobileWebOnly,proto3" json:"$mobile_web_only,omitempty"`
}

func (m *RedirectionsConfig) Reset()         { *m = RedirectionsConfig{} }
func (m *RedirectionsConfig) String() string { return proto.CompactTextString(m) }
func (*RedirectionsConfig) ProtoMessage()    {}
func (*RedirectionsConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_10e7b6bdafd859e9, []int{3}
}
func (m *RedirectionsConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RedirectionsConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RedirectionsConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RedirectionsConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RedirectionsConfig.Merge(m, src)
}
func (m *RedirectionsConfig) XXX_Size() int {
	return m.Size()
}
func (m *RedirectionsConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RedirectionsConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RedirectionsConfig proto.InternalMessageInfo

func (m *RedirectionsConfig) GetFallbackUrl() string {
	if m != nil {
		return m.FallbackUrl
	}
	return ""
}

func (m *RedirectionsConfig) GetDesktopUrl() string {
	if m != nil {
		return m.DesktopUrl
	}
	return ""
}

func (m *RedirectionsConfig) GetIosUrl() string {
	if m != nil {
		return m.IosUrl
	}
	return ""
}

func (m *RedirectionsConfig) GetAndroidUrl() string {
	if m != nil {
		return m.AndroidUrl
	}
	return ""
}

func (m *RedirectionsConfig) GetWebOnly() bool {
	if m != nil {
		return m.WebOnly
	}
	return false
}

func (m *RedirectionsConfig) GetDesktopWebOnly() bool {
	if m != nil {
		return m.DesktopWebOnly
	}
	return false
}

func (m *RedirectionsConfig) GetMobileWebOnly() bool {
	if m != nil {
		return m.MobileWebOnly
	}
	return false
}

// DeepLinkConfig contains the deep link properties that will be added to the
// generated link
type DeepLinkConfig struct {
	// Set the deep link path for all platforms - so you don't have to enable it
	// by platform. When the Branch SDK receives a link with this parameter set,
	// it will automatically load the custom URI path contained within. Default:
	// open?link_click_id=1234
	DeepLinkPath string `protobuf:"bytes,1,opt,name=deep_link_path,json=deepLinkPath,proto3" json:"$deeplink_path,omitempty"`
	// Set the deep link path for Android apps. When the Branch SDK receives a
	// link with this parameter set, it will automatically load the custom Android
	// URI path contained within
	AndroidDeepLinkPath string `protobuf:"bytes,2,opt,name=android_deep_link_path,json=androidDeepLinkPath,proto3" json:"$android_deeplink_path,omitempty"`
	// Set the deep link path for iOS apps. When the Branch SDK receives a link
	// with this parameter set, it will automatically load the custom iOS URI path
	// contained within
	IosDeepLinkPath string `protobuf:"bytes,3,opt,name=ios_deep_link_path,json=iosDeepLinkPath,proto3" json:"$ios_deeplink_path,omitempty"`
	// Set the deep link path for Desktop apps. You will have to fetch this
	// parameter and route the user accordingly
	DesktopDeepLinkPath string `protobuf:"bytes,4,opt,name=desktop_deep_link_path,json=desktopDeepLinkPath,proto3" json:"$desktop_deeplink_path,omitempty"`
}

func (m *DeepLinkConfig) Reset()         { *m = DeepLinkConfig{} }
func (m *DeepLinkConfig) String() string { return proto.CompactTextString(m) }
func (*DeepLinkConfig) ProtoMessage()    {}
func (*DeepLinkConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_10e7b6bdafd859e9, []int{4}
}
func (m *DeepLinkConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeepLinkConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeepLinkConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeepLinkConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeepLinkConfig.Merge(m, src)
}
func (m *DeepLinkConfig) XXX_Size() int {
	return m.Size()
}
func (m *DeepLinkConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_DeepLinkConfig.DiscardUnknown(m)
}

var xxx_messageInfo_DeepLinkConfig proto.InternalMessageInfo

func (m *DeepLinkConfig) GetDeepLinkPath() string {
	if m != nil {
		return m.DeepLinkPath
	}
	return ""
}

func (m *DeepLinkConfig) GetAndroidDeepLinkPath() string {
	if m != nil {
		return m.AndroidDeepLinkPath
	}
	return ""
}

func (m *DeepLinkConfig) GetIosDeepLinkPath() string {
	if m != nil {
		return m.IosDeepLinkPath
	}
	return ""
}

func (m *DeepLinkConfig) GetDesktopDeepLinkPath() string {
	if m != nil {
		return m.DesktopDeepLinkPath
	}
	return ""
}

func init() {
	proto.RegisterType((*LinkConfig)(nil), "caerus.types.v1.LinkConfig")
	proto.RegisterType((*OpenGraphConfig)(nil), "caerus.types.v1.OpenGraphConfig")
	proto.RegisterType((*TwitterConfig)(nil), "caerus.types.v1.TwitterConfig")
	proto.RegisterType((*RedirectionsConfig)(nil), "caerus.types.v1.RedirectionsConfig")
	proto.RegisterType((*DeepLinkConfig)(nil), "caerus.types.v1.DeepLinkConfig")
}

func init() { proto.RegisterFile("caerus/types/v1/links.proto", fileDescriptor_10e7b6bdafd859e9) }

var fileDescriptor_10e7b6bdafd859e9 = []byte{
	// 766 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x95, 0xcf, 0x4f, 0xdb, 0x48,
	0x14, 0xc7, 0x09, 0x01, 0x42, 0x26, 0x21, 0x41, 0xc3, 0x0a, 0xb2, 0xc0, 0x7a, 0xa2, 0x90, 0x03,
	0x87, 0x25, 0x59, 0xd8, 0xcb, 0x4a, 0x2b, 0x76, 0xa5, 0x34, 0x6d, 0x55, 0xa9, 0x15, 0x55, 0x04,
	0xaa, 0xe8, 0xc5, 0x72, 0xe2, 0xc1, 0x19, 0xc5, 0xf1, 0x58, 0xf6, 0x04, 0x94, 0x6b, 0x2f, 0xbd,
	0xf6, 0xff, 0xe9, 0xbd, 0xea, 0x91, 0x63, 0x7b, 0xb1, 0x2a, 0xb8, 0xf9, 0xaf, 0xa8, 0x3c, 0x33,
	0x0e, 0x2f, 0x0e, 0xad, 0x7a, 0x8b, 0xdf, 0xf7, 0x7d, 0x3f, 0xf3, 0x7e, 0xcc, 0x28, 0x68, 0x6f,
	0x60, 0xd1, 0x60, 0x12, 0xb6, 0xc5, 0xd4, 0xa7, 0x61, 0xfb, 0xfa, 0xb8, 0xed, 0x32, 0x6f, 0x14,
	0xb6, 0xfc, 0x80, 0x0b, 0x8e, 0xab, 0x4a, 0x6c, 0x49, 0xb1, 0x75, 0x7d, 0xbc, 0xfb, 0x9b, 0xc3,
	0x1d, 0x2e, 0xb5, 0x76, 0xf2, 0x4b, 0xa5, 0x35, 0xde, 0xe7, 0x11, 0x7a, 0xc9, 0xbc, 0xd1, 0x13,
	0xee, 0x5d, 0x31, 0x07, 0x9f, 0x21, 0xc4, 0x7d, 0xea, 0x99, 0x4e, 0x60, 0xf9, 0xc3, 0x5a, 0xae,
	0x9e, 0x3b, 0x2c, 0x9d, 0xd4, 0x5b, 0x19, 0x54, 0xeb, 0xcc, 0xa7, 0xde, 0xf3, 0x24, 0x43, 0xb9,
	0x3a, 0x95, 0x38, 0x22, 0xc0, 0xd7, 0x2b, 0xf2, 0x34, 0x01, 0x3f, 0x45, 0x05, 0x71, 0xc3, 0x84,
	0xa0, 0x41, 0x6d, 0x59, 0xd2, 0x8c, 0x05, 0xda, 0xb9, 0xd2, 0x35, 0xab, 0x14, 0x47, 0x24, 0xb5,
	0xf4, 0xd2, 0x1f, 0xf8, 0x2f, 0x54, 0x1a, 0x4c, 0x42, 0xc1, 0xc7, 0xa6, 0x6d, 0x09, 0xab, 0x96,
	0xaf, 0xe7, 0x0e, 0xcb, 0x9d, 0x6a, 0x1c, 0x11, 0x18, 0xee, 0x21, 0xf5, 0xd1, 0xb5, 0x84, 0x85,
	0x2f, 0x51, 0x39, 0xa0, 0x36, 0x0b, 0xe8, 0x40, 0x30, 0xee, 0x85, 0xb5, 0x15, 0x79, 0xfa, 0xc1,
	0xc2, 0xe9, 0x3d, 0x90, 0xa4, 0x4b, 0xd8, 0x8c, 0x23, 0x32, 0x67, 0xee, 0xcd, 0x7d, 0xe1, 0x73,
	0x54, 0xb6, 0x29, 0xf5, 0xcd, 0x64, 0xdc, 0xcc, 0x73, 0x6a, 0xab, 0x12, 0x4d, 0x16, 0xd0, 0x5d,
	0x4a, 0xfd, 0x87, 0xd9, 0x2a, 0x2c, 0x34, 0xf6, 0x4a, 0xb6, 0xce, 0x60, 0x9e, 0xd3, 0xf8, 0x98,
	0x43, 0xd5, 0xcc, 0x60, 0xf1, 0x11, 0x5a, 0x15, 0x4c, 0xb8, 0x54, 0x6e, 0xa2, 0xd8, 0xd9, 0x89,
	0x23, 0xb2, 0xd5, 0xe4, 0x8e, 0x29, 0x83, 0x7f, 0xf2, 0x31, 0x13, 0x74, 0xec, 0x8b, 0x69, 0x4f,
	0x65, 0xe1, 0xff, 0x51, 0xc9, 0xa6, 0xe1, 0x20, 0x60, 0x7e, 0x52, 0xa8, 0x1c, 0x78, 0xb1, 0xf3,
	0x47, 0x1c, 0x91, 0xdf, 0x13, 0x13, 0x90, 0x80, 0x15, 0x3a, 0xf0, 0x3f, 0xa8, 0xc8, 0xc6, 0x96,
	0x43, 0xcd, 0x49, 0xe0, 0xca, 0x21, 0x17, 0x3b, 0x7b, 0x71, 0x44, 0x76, 0x12, 0xfb, 0x4c, 0x00,
	0xe6, 0x75, 0x19, 0xbc, 0x08, 0xdc, 0xc6, 0xbb, 0x65, 0xb4, 0x31, 0xb7, 0xc8, 0x84, 0x35, 0xb0,
	0x02, 0xdb, 0x4c, 0xc6, 0xa1, 0xeb, 0x57, 0x2c, 0xbd, 0x53, 0x33, 0x51, 0x21, 0x2b, 0xf9, 0x3e,
	0x9f, 0xfa, 0x14, 0x9f, 0xa4, 0x5d, 0xab, 0x06, 0xf6, 0xe3, 0x88, 0xd4, 0x66, 0xae, 0x1f, 0xb4,
	0xde, 0x9d, 0x6f, 0x5d, 0xd5, 0xde, 0x88, 0x23, 0x62, 0xcc, 0x9c, 0xbf, 0xd0, 0xff, 0x29, 0xec,
	0x7f, 0x45, 0x32, 0xea, 0x71, 0x44, 0xf6, 0x67, 0x8c, 0x9f, 0x0f, 0xe1, 0x53, 0x1e, 0xe1, 0xc5,
	0xfb, 0x84, 0xff, 0x43, 0xe5, 0x2b, 0xcb, 0x75, 0xfb, 0xd6, 0x60, 0x24, 0xc1, 0x70, 0x18, 0x50,
	0x80, 0x55, 0xa5, 0xf1, 0x8b, 0xc0, 0xc5, 0xff, 0xca, 0xde, 0x46, 0x82, 0xfb, 0xd2, 0xae, 0xa6,
	0xb2, 0x1b, 0x47, 0x64, 0xbb, 0x09, 0xe2, 0xc0, 0x8d, 0x74, 0x38, 0x31, 0xb7, 0x51, 0x81, 0xf1,
	0x10, 0x2c, 0x74, 0x3b, 0x8e, 0x08, 0x6e, 0xea, 0x18, 0x30, 0xad, 0x31, 0x1e, 0xea, 0xd3, 0x2c,
	0xcf, 0x0e, 0x38, 0xb3, 0xc1, 0x14, 0xd4, 0x69, 0x20, 0x0e, 0x4f, 0xd3, 0xe1, 0xc4, 0x7c, 0x82,
	0xd6, 0x6f, 0x68, 0xdf, 0xe4, 0x9e, 0x3b, 0x95, 0xcf, 0x62, 0x5d, 0xdf, 0xd9, 0x34, 0x08, 0x6c,
	0x85, 0x1b, 0xda, 0x3f, 0xf3, 0xdc, 0x29, 0x7e, 0x81, 0x36, 0xd3, 0x36, 0x66, 0xde, 0x35, 0xe9,
	0x25, 0x71, 0x44, 0xf6, 0x9a, 0x59, 0x11, 0x30, 0x2a, 0x5a, 0x7b, 0xa3, 0x51, 0xcf, 0x50, 0x75,
	0xcc, 0xfb, 0xcc, 0xa5, 0x0f, 0xa4, 0x82, 0x24, 0x19, 0x71, 0x44, 0x76, 0x9b, 0x19, 0x0d, 0x80,
	0x36, 0x94, 0xa4, 0x39, 0x8d, 0xaf, 0xcb, 0xa8, 0x32, 0xff, 0x7a, 0x71, 0x07, 0x55, 0x66, 0x6f,
	0xd7, 0xf4, 0x2d, 0x31, 0xd4, 0x6b, 0x54, 0xb7, 0x33, 0x91, 0x66, 0x0a, 0xe0, 0x96, 0xd3, 0x17,
	0xfe, 0xda, 0x12, 0x43, 0x7c, 0x89, 0xb6, 0xd3, 0x11, 0x66, 0x58, 0x6a, 0xa7, 0xcd, 0x38, 0x22,
	0xf5, 0x26, 0x4c, 0x79, 0x8c, 0xb9, 0xa5, 0x13, 0xba, 0x10, 0xfd, 0x0a, 0xe1, 0x64, 0xa5, 0x19,
	0x6c, 0x1e, 0x5c, 0xe1, 0x54, 0x7e, 0x0c, 0x59, 0x65, 0x3c, 0xec, 0x66, 0x2a, 0x4d, 0xc7, 0x9e,
	0x41, 0xae, 0x80, 0x4a, 0x61, 0xca, 0xa3, 0x95, 0xea, 0x04, 0x88, 0xee, 0x9c, 0x7e, 0xbe, 0x33,
	0x72, 0xb7, 0x77, 0x46, 0xee, 0xdb, 0x9d, 0x91, 0xfb, 0x70, 0x6f, 0x2c, 0xdd, 0xde, 0x1b, 0x4b,
	0x5f, 0xee, 0x8d, 0xa5, 0xb7, 0x07, 0x0e, 0x13, 0xc3, 0x49, 0xbf, 0x35, 0xe0, 0xe3, 0xb6, 0x4d,
	0xc3, 0x31, 0x0f, 0x8f, 0x5c, 0xab, 0x1f, 0xb6, 0xe1, 0xdf, 0x5c, 0x7f, 0x4d, 0xfe, 0x6f, 0xfd,
	0xfd, 0x3d, 0x00, 0x00, 0xff, 0xff, 0xe8, 0xa3, 0xb6, 0x34, 0xfd, 0x06, 0x00, 0x00,
}

func (m *LinkConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeepLinking != nil {
		{
			size, err := m.DeepLinking.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLinks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Redirections != nil {
		{
			size, err := m.Redirections.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLinks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.CustomData) > 0 {
		i -= len(m.CustomData)
		copy(dAtA[i:], m.CustomData)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.CustomData)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Twitter != nil {
		{
			size, err := m.Twitter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLinks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.OpenGraph != nil {
		{
			size, err := m.OpenGraph.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLinks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OpenGraphConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenGraphConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpenGraphConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImageUrl) > 0 {
		i -= len(m.ImageUrl)
		copy(dAtA[i:], m.ImageUrl)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.ImageUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TwitterConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TwitterConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TwitterConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ImageUrl) > 0 {
		i -= len(m.ImageUrl)
		copy(dAtA[i:], m.ImageUrl)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.ImageUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CardType) > 0 {
		i -= len(m.CardType)
		copy(dAtA[i:], m.CardType)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.CardType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RedirectionsConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RedirectionsConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RedirectionsConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MobileWebOnly {
		i--
		if m.MobileWebOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.DesktopWebOnly {
		i--
		if m.DesktopWebOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.WebOnly {
		i--
		if m.WebOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.AndroidUrl) > 0 {
		i -= len(m.AndroidUrl)
		copy(dAtA[i:], m.AndroidUrl)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.AndroidUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IosUrl) > 0 {
		i -= len(m.IosUrl)
		copy(dAtA[i:], m.IosUrl)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.IosUrl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DesktopUrl) > 0 {
		i -= len(m.DesktopUrl)
		copy(dAtA[i:], m.DesktopUrl)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.DesktopUrl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.FallbackUrl) > 0 {
		i -= len(m.FallbackUrl)
		copy(dAtA[i:], m.FallbackUrl)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.FallbackUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeepLinkConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeepLinkConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeepLinkConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DesktopDeepLinkPath) > 0 {
		i -= len(m.DesktopDeepLinkPath)
		copy(dAtA[i:], m.DesktopDeepLinkPath)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.DesktopDeepLinkPath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IosDeepLinkPath) > 0 {
		i -= len(m.IosDeepLinkPath)
		copy(dAtA[i:], m.IosDeepLinkPath)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.IosDeepLinkPath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AndroidDeepLinkPath) > 0 {
		i -= len(m.AndroidDeepLinkPath)
		copy(dAtA[i:], m.AndroidDeepLinkPath)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.AndroidDeepLinkPath)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeepLinkPath) > 0 {
		i -= len(m.DeepLinkPath)
		copy(dAtA[i:], m.DeepLinkPath)
		i = encodeVarintLinks(dAtA, i, uint64(len(m.DeepLinkPath)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLinks(dAtA []byte, offset int, v uint64) int {
	offset -= sovLinks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LinkConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OpenGraph != nil {
		l = m.OpenGraph.Size()
		n += 1 + l + sovLinks(uint64(l))
	}
	if m.Twitter != nil {
		l = m.Twitter.Size()
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.CustomData)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	if m.Redirections != nil {
		l = m.Redirections.Size()
		n += 1 + l + sovLinks(uint64(l))
	}
	if m.DeepLinking != nil {
		l = m.DeepLinking.Size()
		n += 1 + l + sovLinks(uint64(l))
	}
	return n
}

func (m *OpenGraphConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	return n
}

func (m *TwitterConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CardType)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.ImageUrl)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	return n
}

func (m *RedirectionsConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FallbackUrl)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.DesktopUrl)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.IosUrl)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.AndroidUrl)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	if m.WebOnly {
		n += 2
	}
	if m.DesktopWebOnly {
		n += 2
	}
	if m.MobileWebOnly {
		n += 2
	}
	return n
}

func (m *DeepLinkConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeepLinkPath)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.AndroidDeepLinkPath)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.IosDeepLinkPath)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	l = len(m.DesktopDeepLinkPath)
	if l > 0 {
		n += 1 + l + sovLinks(uint64(l))
	}
	return n
}

func sovLinks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLinks(x uint64) (n int) {
	return sovLinks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LinkConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLinks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenGraph", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenGraph == nil {
				m.OpenGraph = &OpenGraphConfig{}
			}
			if err := m.OpenGraph.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Twitter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Twitter == nil {
				m.Twitter = &TwitterConfig{}
			}
			if err := m.Twitter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomData = append(m.CustomData[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomData == nil {
				m.CustomData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Redirections == nil {
				m.Redirections = &RedirectionsConfig{}
			}
			if err := m.Redirections.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeepLinking", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeepLinking == nil {
				m.DeepLinking = &DeepLinkConfig{}
			}
			if err := m.DeepLinking.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLinks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLinks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenGraphConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLinks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenGraphConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenGraphConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLinks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLinks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TwitterConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLinks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TwitterConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TwitterConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLinks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLinks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RedirectionsConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLinks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RedirectionsConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RedirectionsConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FallbackUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesktopUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IosUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IosUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WebOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WebOnly = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopWebOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DesktopWebOnly = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobileWebOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MobileWebOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipLinks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLinks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeepLinkConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLinks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeepLinkConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeepLinkConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeepLinkPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeepLinkPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidDeepLinkPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AndroidDeepLinkPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IosDeepLinkPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IosDeepLinkPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesktopDeepLinkPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLinks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLinks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DesktopDeepLinkPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLinks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLinks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLinks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLinks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLinks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLinks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLinks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLinks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLinks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLinks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLinks = fmt.Errorf("proto: unexpected end of group")
)
